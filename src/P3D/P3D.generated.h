// Copyright 2019 the donut authors. See AUTHORS.md

#pragma once

/*+---------------------------------------------------+
  |    _____        /--------------------------\\     |
  |   /     \\      |                            |    |
  | \\/\\/     |    /  file generated by         |    |
  |  |  (o)(o)    |                  donut tool  |    |
  |  C   .---_)   \\_   _________________________/    |
  |   | |.___|      | /                               |
  |   |  \\__/      <_/                               |
  |   /_____\\                                        |
  |  /_____/ \\                                       |
  | /         \\                                      |
  +---------------------------------------------------+
*/

#include <P3D/P3DChunk.h>
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
#include <glm/vec4.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/mat4x4.hpp>
#include <string>
#include <memory>
#include <vector>
#include <map>

namespace Donut::P3D
{
	class Animation;
	class AnimationSize;
	class AnimationGroupList;
	class AnimationGroup;
	class ChannelInterpolationMode;
	class Vector2Channel;
	class Vector3Channel;
	class QuaternionChannel;
	class CompressedQuaternionChannel;
	class Mesh;
	class PolySkin;
	class BoundingBox;
	class BoundingSphere;
	class PrimitiveGroup;
	class PositionList;
	class IndexList;
	class NormalList;
	class UVList;
	class MatrixList;
	class MatrixPalette;
	class WeightList;
	class ColorList;
	class Skeleton;
	class SkeletonJoint;
	class SkeletonJointMirrorMap;
	class SkeletonJointBonePreserve;
	class StaticEntity;
	class StaticPhysics;
	class InstancedStaticPhysics;
	class DynamicPhysics;
	class AnimDynamicPhysics;
	class AnimObjectWrapper;
	class InstanceList;
	class SceneGraph;
	class SceneGraphRoot;
	class SceneGraphBranch;
	class SceneGraphTransform;
	class SceneGraphDrawable;
	class SceneGraphSortOrder;
	class Shader;
	class ShaderTextureParam;
	class ShaderIntParam;
	class ShaderFloatParam;
	class ShaderColorParam;
	class CompositeDrawable;
	class CompositeDrawablePropList;
	class CompositeDrawableProp;
	class CompositeDrawableSortOrder;
	class Intersect;
	class WorldSphere;
	class LensFlare;
	class BillboardQuad;
	class BillboardQuadGroup;
	class BillboardDisplayInfo;
	class BillboardPerspectiveInfo;
	class Texture;
	class Image;
	class ImageData;
	class TextureFont;
	class FontGlyphs;
	class Sprite;
	class FrontendScreen;
	class FrontendProject;
	class FrontendPage;
	class FrontendLayer;
	class FrontendGroup;
	class FrontendMultiSprite;
	class FrontendMultiText;
	class FrontendStringTextBible;
	class FrontendObject;
	class FrontendPolygon;
	class FrontendImageResource;
	class Locator2;
	class TriggerVolume;
	class Camera;
	class MultiController;
	class MultiControllerTracks;
	class CollisionObject;
	class CollisionVolume;
	class CollisionSphere;
	class CollisionCylinder;
	class CollisionOBBoxVolume;
	class CollisionBBoxVolume;
	class CollisionVector;
	class CollisionVolumeOwner;
	class CollisionVolumeOwnerName;
	class CollisionObjectAttribute;
	class FenceWrapper;
	class Fence;
	class Set;
	class Path;
	class Intersection;
	class RoadDataSegment;
	class Road;
	class GameAttr;
	class GameAttrIntParam ;
	class History;

    class Animation
    {
    public:

        Animation(const P3DChunk&);

        static std::unique_ptr<Animation> Load(const P3DChunk& chunk) { return std::make_unique<Animation>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const std::string& GetType() const { return _type; }
        const float& GetNumFrames() const { return _numFrames; }
        const float& GetFrameRate() const { return _frameRate; }
        const uint32_t& GetLooping() const { return _looping; }
        const std::unique_ptr<AnimationGroupList>& GetGroupList() const { return _groupList; }
        const std::unique_ptr<AnimationSize>& GetSize() const { return _size; }

    private:

        uint32_t _version;
        std::string _name;
        std::string _type;
        float _numFrames;
        float _frameRate;
        uint32_t _looping;
        std::unique_ptr<AnimationGroupList> _groupList;
        std::unique_ptr<AnimationSize> _size;

    };

    class AnimationSize
    {
    public:

        AnimationSize(const P3DChunk&);

        static std::unique_ptr<AnimationSize> Load(const P3DChunk& chunk) { return std::make_unique<AnimationSize>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetPC() const { return _PC; }
        const uint32_t& GetPS2() const { return _PS2; }
        const uint32_t& GetXBOX() const { return _XBOX; }
        const uint32_t& GetGC() const { return _GC; }

    private:

        uint32_t _version;
        uint32_t _PC;
        uint32_t _PS2;
        uint32_t _XBOX;
        uint32_t _GC;

    };

    class AnimationGroupList
    {
    public:

        AnimationGroupList(const P3DChunk&);

        static std::unique_ptr<AnimationGroupList> Load(const P3DChunk& chunk) { return std::make_unique<AnimationGroupList>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetNumGroups() const { return _numGroups; }
        const std::vector<std::unique_ptr<AnimationGroup>>& GetGroups() const { return _groups; }

    private:

        uint32_t _version;
        uint32_t _numGroups;
        std::vector<std::unique_ptr<AnimationGroup>> _groups;

    };

    class AnimationGroup
    {
    public:

        AnimationGroup(const P3DChunk&);

        static std::unique_ptr<AnimationGroup> Load(const P3DChunk& chunk) { return std::make_unique<AnimationGroup>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const uint32_t& GetGroupId() const { return _groupId; }
        const uint32_t& GetNumChannels() const { return _numChannels; }
        Vector2Channel* GetVector2ChannelsValue(const std::string& key) const { auto it = _vector2Channels.find(key); return (it != _vector2Channels.end()) ? it->second.get() : nullptr; }
        Vector3Channel* GetVector3ChannelsValue(const std::string& key) const { auto it = _vector3Channels.find(key); return (it != _vector3Channels.end()) ? it->second.get() : nullptr; }
        QuaternionChannel* GetQuaternionChannelsValue(const std::string& key) const { auto it = _quaternionChannels.find(key); return (it != _quaternionChannels.end()) ? it->second.get() : nullptr; }
        CompressedQuaternionChannel* GetCompressedQuaternionChannelsValue(const std::string& key) const { auto it = _compressedQuaternionChannels.find(key); return (it != _compressedQuaternionChannels.end()) ? it->second.get() : nullptr; }

    private:

        uint32_t _version;
        std::string _name;
        uint32_t _groupId;
        uint32_t _numChannels;
        std::map<std::string, std::unique_ptr<Vector2Channel>> _vector2Channels;
        std::map<std::string, std::unique_ptr<Vector3Channel>> _vector3Channels;
        std::map<std::string, std::unique_ptr<QuaternionChannel>> _quaternionChannels;
        std::map<std::string, std::unique_ptr<CompressedQuaternionChannel>> _compressedQuaternionChannels;

    };

    class ChannelInterpolationMode
    {
    public:

        ChannelInterpolationMode(const P3DChunk&);

        static std::unique_ptr<ChannelInterpolationMode> Load(const P3DChunk& chunk) { return std::make_unique<ChannelInterpolationMode>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetMode() const { return _mode; }

    private:

        uint32_t _version;
        uint32_t _mode;

    };

    class Vector2Channel
    {
    public:

        Vector2Channel(const P3DChunk&);

        static std::unique_ptr<Vector2Channel> Load(const P3DChunk& chunk) { return std::make_unique<Vector2Channel>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetParam() const { return _param; }
        const uint16_t& GetMapping() const { return _mapping; }
        const glm::vec3& GetConstants() const { return _constants; }
        const uint32_t& GetNumFrames() const { return _numFrames; }
        const std::vector<uint16_t>& GetFrames() const { return _frames; }
        const std::vector<glm::vec2>& GetValues() const { return _values; }
        const std::unique_ptr<ChannelInterpolationMode>& GetInterpolationMode() const { return _interpolationMode; }

    private:

        uint32_t _version;
        std::string _param;
        uint16_t _mapping;
        glm::vec3 _constants;
        uint32_t _numFrames;
        std::vector<uint16_t> _frames;
        std::vector<glm::vec2> _values;
        std::unique_ptr<ChannelInterpolationMode> _interpolationMode;

    };

    class Vector3Channel
    {
    public:

        Vector3Channel(const P3DChunk&);

        static std::unique_ptr<Vector3Channel> Load(const P3DChunk& chunk) { return std::make_unique<Vector3Channel>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetParam() const { return _param; }
        const uint32_t& GetNumFrames() const { return _numFrames; }
        const std::vector<uint16_t>& GetFrames() const { return _frames; }
        const std::vector<glm::vec3>& GetValues() const { return _values; }
        const std::unique_ptr<ChannelInterpolationMode>& GetInterpolationMode() const { return _interpolationMode; }

    private:

        uint32_t _version;
        std::string _param;
        uint32_t _numFrames;
        std::vector<uint16_t> _frames;
        std::vector<glm::vec3> _values;
        std::unique_ptr<ChannelInterpolationMode> _interpolationMode;

    };

    class QuaternionChannel
    {
    public:

        QuaternionChannel(const P3DChunk&);

        static std::unique_ptr<QuaternionChannel> Load(const P3DChunk& chunk) { return std::make_unique<QuaternionChannel>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetParam() const { return _param; }
        const uint32_t& GetNumFrames() const { return _numFrames; }
        const std::vector<uint16_t>& GetFrames() const { return _frames; }
        const std::vector<glm::quat>& GetValues() const { return _values; }
        const std::unique_ptr<ChannelInterpolationMode>& GetInterpolationMode() const { return _interpolationMode; }

    private:

        uint32_t _version;
        std::string _param;
        uint32_t _numFrames;
        std::vector<uint16_t> _frames;
        std::vector<glm::quat> _values;
        std::unique_ptr<ChannelInterpolationMode> _interpolationMode;

    };

    class CompressedQuaternionChannel
    {
    public:

        CompressedQuaternionChannel(const P3DChunk&);

        static std::unique_ptr<CompressedQuaternionChannel> Load(const P3DChunk& chunk) { return std::make_unique<CompressedQuaternionChannel>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetParam() const { return _param; }
        const uint32_t& GetNumFrames() const { return _numFrames; }
        const std::vector<uint16_t>& GetFrames() const { return _frames; }
        const std::vector<uint64_t>& GetValues() const { return _values; }
        const std::unique_ptr<ChannelInterpolationMode>& GetInterpolationMode() const { return _interpolationMode; }

    private:

        uint32_t _version;
        std::string _param;
        uint32_t _numFrames;
        std::vector<uint16_t> _frames;
        std::vector<uint64_t> _values;
        std::unique_ptr<ChannelInterpolationMode> _interpolationMode;

    };

    class Mesh
    {
    public:

        Mesh(const P3DChunk&);

        static std::unique_ptr<Mesh> Load(const P3DChunk& chunk) { return std::make_unique<Mesh>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetNumPrimGroups() const { return _numPrimGroups; }
        const std::vector<std::unique_ptr<PrimitiveGroup>>& GetPrimitiveGroups() const { return _primitiveGroups; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _numPrimGroups;
        std::vector<std::unique_ptr<PrimitiveGroup>> _primitiveGroups;

    };

    class PolySkin
    {
    public:

        PolySkin(const P3DChunk&);

        static std::unique_ptr<PolySkin> Load(const P3DChunk& chunk) { return std::make_unique<PolySkin>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetSkeletonName() const { return _skeletonName; }
        const uint32_t& GetNumPrimGroups() const { return _numPrimGroups; }
        const std::vector<std::unique_ptr<PrimitiveGroup>>& GetPrimitiveGroups() const { return _primitiveGroups; }
        const std::unique_ptr<BoundingBox>& GetBoundingBox() const { return _boundingBox; }
        const std::unique_ptr<BoundingSphere>& GetBoundingSphere() const { return _boundingSphere; }

    private:

        std::string _name;
        uint32_t _version;
        std::string _skeletonName;
        uint32_t _numPrimGroups;
        std::vector<std::unique_ptr<PrimitiveGroup>> _primitiveGroups;
        std::unique_ptr<BoundingBox> _boundingBox;
        std::unique_ptr<BoundingSphere> _boundingSphere;

    };

    class BoundingBox
    {
    public:

        BoundingBox(const P3DChunk&);

        static std::unique_ptr<BoundingBox> Load(const P3DChunk& chunk) { return std::make_unique<BoundingBox>(chunk); }

        const glm::vec3& GetMin() const { return _min; }
        const glm::vec3& GetMax() const { return _max; }

    private:

        glm::vec3 _min;
        glm::vec3 _max;

    };

    class BoundingSphere
    {
    public:

        BoundingSphere(const P3DChunk&);

        static std::unique_ptr<BoundingSphere> Load(const P3DChunk& chunk) { return std::make_unique<BoundingSphere>(chunk); }

        const glm::vec3& GetCentre() const { return _centre; }
        const float& GetRadius() const { return _radius; }

    private:

        glm::vec3 _centre;
        float _radius;

    };

    class PrimitiveGroup
    {
    public:

        PrimitiveGroup(const P3DChunk&);

        static std::unique_ptr<PrimitiveGroup> Load(const P3DChunk& chunk) { return std::make_unique<PrimitiveGroup>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetShaderName() const { return _shaderName; }
        const uint32_t& GetPrimType() const { return _primType; }
        const uint32_t& GetHasDataFlags() const { return _hasDataFlags; }
        const uint32_t& GetNumVerts() const { return _numVerts; }
        const uint32_t& GetNumIndices() const { return _numIndices; }
        const uint32_t& GetNumMatrices() const { return _numMatrices; }
        const std::vector<glm::vec3>& GetVertices() const { return _vertices; }
        const std::vector<uint32_t>& GetIndices() const { return _indices; }
        const std::vector<glm::vec3>& GetNormals() const { return _normals; }
        const std::vector<glm::vec2>& GetUvs(size_t index) const { return _uvs.at(index); }
        const std::vector<uint32_t>& GetMatrixList() const { return _matrixList; }
        const std::vector<uint32_t>& GetMatrixPalette() const { return _matrixPalette; }
        const std::vector<glm::vec3>& GetWeightList() const { return _weightList; }
        const std::vector<uint32_t>& GetColors() const { return _colors; }

    private:

        uint32_t _version;
        std::string _shaderName;
        uint32_t _primType;
        uint32_t _hasDataFlags;
        uint32_t _numVerts;
        uint32_t _numIndices;
        uint32_t _numMatrices;
        std::vector<glm::vec3> _vertices;
        std::vector<uint32_t> _indices;
        std::vector<glm::vec3> _normals;
        std::vector<std::vector<glm::vec2>> _uvs;
        std::vector<uint32_t> _matrixList;
        std::vector<uint32_t> _matrixPalette;
        std::vector<glm::vec3> _weightList;
        std::vector<uint32_t> _colors;

    };

    class PositionList
    {
    public:

        PositionList(const P3DChunk&);

        static std::unique_ptr<PositionList> Load(const P3DChunk& chunk) { return std::make_unique<PositionList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<glm::vec3>& GetPositions() const { return _positions; }

    private:

        uint32_t _size;
        std::vector<glm::vec3> _positions;

    };

    class IndexList
    {
    public:

        IndexList(const P3DChunk&);

        static std::unique_ptr<IndexList> Load(const P3DChunk& chunk) { return std::make_unique<IndexList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<uint32_t>& GetIndices() const { return _indices; }

    private:

        uint32_t _size;
        std::vector<uint32_t> _indices;

    };

    class NormalList
    {
    public:

        NormalList(const P3DChunk&);

        static std::unique_ptr<NormalList> Load(const P3DChunk& chunk) { return std::make_unique<NormalList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<glm::vec3>& GetNormals() const { return _normals; }

    private:

        uint32_t _size;
        std::vector<glm::vec3> _normals;

    };

    class UVList
    {
    public:

        UVList(const P3DChunk&);

        static std::unique_ptr<UVList> Load(const P3DChunk& chunk) { return std::make_unique<UVList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const uint32_t& GetChannel() const { return _channel; }
        const std::vector<glm::vec2>& GetUvs() const { return _uvs; }

    private:

        uint32_t _size;
        uint32_t _channel;
        std::vector<glm::vec2> _uvs;

    };

    class MatrixList
    {
    public:

        MatrixList(const P3DChunk&);

        static std::unique_ptr<MatrixList> Load(const P3DChunk& chunk) { return std::make_unique<MatrixList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<uint32_t>& GetUvs() const { return _uvs; }

    private:

        uint32_t _size;
        std::vector<uint32_t> _uvs;

    };

    class MatrixPalette
    {
    public:

        MatrixPalette(const P3DChunk&);

        static std::unique_ptr<MatrixPalette> Load(const P3DChunk& chunk) { return std::make_unique<MatrixPalette>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<uint32_t>& GetUvs() const { return _uvs; }

    private:

        uint32_t _size;
        std::vector<uint32_t> _uvs;

    };

    class WeightList
    {
    public:

        WeightList(const P3DChunk&);

        static std::unique_ptr<WeightList> Load(const P3DChunk& chunk) { return std::make_unique<WeightList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<glm::vec3>& GetUvs() const { return _uvs; }

    private:

        uint32_t _size;
        std::vector<glm::vec3> _uvs;

    };

    class ColorList
    {
    public:

        ColorList(const P3DChunk&);

        static std::unique_ptr<ColorList> Load(const P3DChunk& chunk) { return std::make_unique<ColorList>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<uint32_t>& GetUvs() const { return _uvs; }

    private:

        uint32_t _size;
        std::vector<uint32_t> _uvs;

    };

    class Skeleton
    {
    public:

        Skeleton(const P3DChunk&);

        static std::unique_ptr<Skeleton> Load(const P3DChunk& chunk) { return std::make_unique<Skeleton>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetNumJoints() const { return _numJoints; }
        const std::vector<std::unique_ptr<SkeletonJoint>>& GetJoints() const { return _joints; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _numJoints;
        std::vector<std::unique_ptr<SkeletonJoint>> _joints;

    };

    class SkeletonJoint
    {
    public:

        SkeletonJoint(const P3DChunk&);

        static std::unique_ptr<SkeletonJoint> Load(const P3DChunk& chunk) { return std::make_unique<SkeletonJoint>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetParent() const { return _parent; }
        const int32_t& GetDof() const { return _dof; }
        const int32_t& GetFreeAxis() const { return _freeAxis; }
        const int32_t& GetPrimaryAxis() const { return _primaryAxis; }
        const int32_t& GetSecondaryAxis() const { return _secondaryAxis; }
        const int32_t& GetTwistAxis() const { return _twistAxis; }
        const glm::mat4& GetRestPose() const { return _restPose; }
        const std::unique_ptr<SkeletonJointMirrorMap>& GetMirrorMap() const { return _mirrorMap; }
        const std::unique_ptr<SkeletonJointBonePreserve>& GetBonePreserve() const { return _bonePreserve; }

    private:

        std::string _name;
        uint32_t _parent;
        int32_t _dof;
        int32_t _freeAxis;
        int32_t _primaryAxis;
        int32_t _secondaryAxis;
        int32_t _twistAxis;
        glm::mat4 _restPose;
        std::unique_ptr<SkeletonJointMirrorMap> _mirrorMap;
        std::unique_ptr<SkeletonJointBonePreserve> _bonePreserve;

    };

    class SkeletonJointMirrorMap
    {
    public:

        SkeletonJointMirrorMap(const P3DChunk&);

        static std::unique_ptr<SkeletonJointMirrorMap> Load(const P3DChunk& chunk) { return std::make_unique<SkeletonJointMirrorMap>(chunk); }

        const uint32_t& GetJointIndex() const { return _jointIndex; }
        const glm::vec3& GetAxis() const { return _axis; }

    private:

        uint32_t _jointIndex;
        glm::vec3 _axis;

    };

    class SkeletonJointBonePreserve
    {
    public:

        SkeletonJointBonePreserve(const P3DChunk&);

        static std::unique_ptr<SkeletonJointBonePreserve> Load(const P3DChunk& chunk) { return std::make_unique<SkeletonJointBonePreserve>(chunk); }

        const uint32_t& GetDepth() const { return _depth; }

    private:

        uint32_t _depth;

    };

    class StaticEntity
    {
    public:

        StaticEntity(const P3DChunk&);

        static std::unique_ptr<StaticEntity> Load(const P3DChunk& chunk) { return std::make_unique<StaticEntity>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetRenderOrder() const { return _renderOrder; }
        const std::unique_ptr<Mesh>& GetMesh() const { return _mesh; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _renderOrder;
        std::unique_ptr<Mesh> _mesh;

    };

    class StaticPhysics
    {
    public:

        StaticPhysics(const P3DChunk&);

        static std::unique_ptr<StaticPhysics> Load(const P3DChunk& chunk) { return std::make_unique<StaticPhysics>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo() const { return _todo; }
        const std::unique_ptr<CollisionObject>& GetCollisionObject() const { return _collisionObject; }

    private:

        std::string _name;
        uint32_t _todo;
        std::unique_ptr<CollisionObject> _collisionObject;

    };

    class InstancedStaticPhysics
    {
    public:

        InstancedStaticPhysics(const P3DChunk&);

        static std::unique_ptr<InstancedStaticPhysics> Load(const P3DChunk& chunk) { return std::make_unique<InstancedStaticPhysics>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo() const { return _todo; }
        const uint32_t& GetRenderOrder() const { return _renderOrder; }
        const std::vector<std::unique_ptr<Mesh>>& GetMeshes() const { return _meshes; }
        const std::unique_ptr<InstanceList>& GetInstanceList() const { return _instanceList; }

    private:

        std::string _name;
        uint32_t _todo;
        uint32_t _renderOrder;
        std::vector<std::unique_ptr<Mesh>> _meshes;
        std::unique_ptr<InstanceList> _instanceList;

    };

    class DynamicPhysics
    {
    public:

        DynamicPhysics(const P3DChunk&);

        static std::unique_ptr<DynamicPhysics> Load(const P3DChunk& chunk) { return std::make_unique<DynamicPhysics>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo() const { return _todo; }
        const uint32_t& GetRenderOrder() const { return _renderOrder; }
        const std::vector<std::unique_ptr<Mesh>>& GetMeshes() const { return _meshes; }
        const std::unique_ptr<InstanceList>& GetInstanceList() const { return _instanceList; }

    private:

        std::string _name;
        uint32_t _todo;
        uint32_t _renderOrder;
        std::vector<std::unique_ptr<Mesh>> _meshes;
        std::unique_ptr<InstanceList> _instanceList;

    };

    class AnimDynamicPhysics
    {
    public:

        AnimDynamicPhysics(const P3DChunk&);

        static std::unique_ptr<AnimDynamicPhysics> Load(const P3DChunk& chunk) { return std::make_unique<AnimDynamicPhysics>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo() const { return _todo; }
        const uint32_t& GetRenderOrder() const { return _renderOrder; }
        const std::unique_ptr<AnimObjectWrapper>& GetAnimObjectWrapper() const { return _animObjectWrapper; }
        const std::unique_ptr<InstanceList>& GetInstanceList() const { return _instanceList; }

    private:

        std::string _name;
        uint32_t _todo;
        uint32_t _renderOrder;
        std::unique_ptr<AnimObjectWrapper> _animObjectWrapper;
        std::unique_ptr<InstanceList> _instanceList;

    };

    class AnimObjectWrapper
    {
    public:

        AnimObjectWrapper(const P3DChunk&);

        static std::unique_ptr<AnimObjectWrapper> Load(const P3DChunk& chunk) { return std::make_unique<AnimObjectWrapper>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint16_t& GetTodo() const { return _todo; }
        const std::vector<std::unique_ptr<CompositeDrawable>>& GetCompositeDrawables() const { return _compositeDrawables; }
        const std::vector<std::unique_ptr<Skeleton>>& GetSkeletons() const { return _skeletons; }
        const std::vector<std::unique_ptr<Mesh>>& GetMeshes() const { return _meshes; }
        const std::vector<std::unique_ptr<Animation>>& GetAnimations() const { return _animations; }

    private:

        std::string _name;
        uint16_t _todo;
        std::vector<std::unique_ptr<CompositeDrawable>> _compositeDrawables;
        std::vector<std::unique_ptr<Skeleton>> _skeletons;
        std::vector<std::unique_ptr<Mesh>> _meshes;
        std::vector<std::unique_ptr<Animation>> _animations;

    };

    class InstanceList
    {
    public:

        InstanceList(const P3DChunk&);

        static std::unique_ptr<InstanceList> Load(const P3DChunk& chunk) { return std::make_unique<InstanceList>(chunk); }

        const std::string& GetName() const { return _name; }
        const std::unique_ptr<SceneGraph>& GetSceneGraph() const { return _sceneGraph; }

    private:

        std::string _name;
        std::unique_ptr<SceneGraph> _sceneGraph;

    };

    class SceneGraph
    {
    public:

        SceneGraph(const P3DChunk&);

        static std::unique_ptr<SceneGraph> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraph>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo() const { return _todo; }
        const std::unique_ptr<SceneGraphRoot>& GetRoot() const { return _root; }

    private:

        std::string _name;
        uint32_t _todo;
        std::unique_ptr<SceneGraphRoot> _root;

    };

    class SceneGraphRoot
    {
    public:

        SceneGraphRoot(const P3DChunk&);

        static std::unique_ptr<SceneGraphRoot> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraphRoot>(chunk); }

        const std::unique_ptr<SceneGraphBranch>& GetBranch() const { return _branch; }

    private:

        std::unique_ptr<SceneGraphBranch> _branch;

    };

    class SceneGraphBranch
    {
    public:

        SceneGraphBranch(const P3DChunk&);

        static std::unique_ptr<SceneGraphBranch> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraphBranch>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetNumChildren() const { return _numChildren; }
        const std::vector<std::unique_ptr<SceneGraphTransform>>& GetChildren() const { return _children; }

    private:

        std::string _name;
        uint32_t _numChildren;
        std::vector<std::unique_ptr<SceneGraphTransform>> _children;

    };

    class SceneGraphTransform
    {
    public:

        SceneGraphTransform(const P3DChunk&);

        static std::unique_ptr<SceneGraphTransform> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraphTransform>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetNumChildren() const { return _numChildren; }
        const glm::mat4& GetTransform() const { return _transform; }
        const std::vector<std::unique_ptr<SceneGraphTransform>>& GetChildren() const { return _children; }
        const std::vector<std::unique_ptr<SceneGraphDrawable>>& GetDrawables() const { return _drawables; }

    private:

        std::string _name;
        uint32_t _numChildren;
        glm::mat4 _transform;
        std::vector<std::unique_ptr<SceneGraphTransform>> _children;
        std::vector<std::unique_ptr<SceneGraphDrawable>> _drawables;

    };

    class SceneGraphDrawable
    {
    public:

        SceneGraphDrawable(const P3DChunk&);

        static std::unique_ptr<SceneGraphDrawable> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraphDrawable>(chunk); }

        const std::string& GetName() const { return _name; }
        const std::string& GetDrawableName() const { return _drawableName; }
        const uint32_t& GetTranslucent() const { return _translucent; }
        const float& GetSortOrder() const { return _sortOrder; }

    private:

        std::string _name;
        std::string _drawableName;
        uint32_t _translucent;
        float _sortOrder;

    };

    class SceneGraphSortOrder
    {
    public:

        SceneGraphSortOrder(const P3DChunk&);

        static std::unique_ptr<SceneGraphSortOrder> Load(const P3DChunk& chunk) { return std::make_unique<SceneGraphSortOrder>(chunk); }

        const float& GetValue() const { return _value; }

    private:

        float _value;

    };

    class Shader
    {
    public:

        Shader(const P3DChunk&);

        static std::unique_ptr<Shader> Load(const P3DChunk& chunk) { return std::make_unique<Shader>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetPddiShaderName() const { return _pddiShaderName; }
        const uint32_t& GetIsTrans() const { return _isTrans; }
        const uint32_t& GetVertexNeeds() const { return _vertexNeeds; }
        const uint32_t& GetVertexMask() const { return _vertexMask; }
        const uint32_t& GetNumParams() const { return _numParams; }
        const std::vector<std::unique_ptr<ShaderTextureParam>>& GetTextureParams() const { return _textureParams; }
        const std::vector<std::unique_ptr<ShaderIntParam>>& GetIntegerParams() const { return _integerParams; }
        const std::vector<std::unique_ptr<ShaderFloatParam>>& GetFloatParams() const { return _floatParams; }
        const std::vector<std::unique_ptr<ShaderColorParam>>& GetColorParams() const { return _colorParams; }

    private:

        std::string _name;
        uint32_t _version;
        std::string _pddiShaderName;
        uint32_t _isTrans;
        uint32_t _vertexNeeds;
        uint32_t _vertexMask;
        uint32_t _numParams;
        std::vector<std::unique_ptr<ShaderTextureParam>> _textureParams;
        std::vector<std::unique_ptr<ShaderIntParam>> _integerParams;
        std::vector<std::unique_ptr<ShaderFloatParam>> _floatParams;
        std::vector<std::unique_ptr<ShaderColorParam>> _colorParams;

    };

    class ShaderTextureParam
    {
    public:

        ShaderTextureParam(const P3DChunk&);

        static std::unique_ptr<ShaderTextureParam> Load(const P3DChunk& chunk) { return std::make_unique<ShaderTextureParam>(chunk); }

        const std::string& GetKey() const { return _key; }
        const std::string& GetValue() const { return _value; }

    private:

        std::string _key;
        std::string _value;

    };

    class ShaderIntParam
    {
    public:

        ShaderIntParam(const P3DChunk&);

        static std::unique_ptr<ShaderIntParam> Load(const P3DChunk& chunk) { return std::make_unique<ShaderIntParam>(chunk); }

        const std::string& GetKey() const { return _key; }
        const int32_t& GetValue() const { return _value; }

    private:

        std::string _key;
        int32_t _value;

    };

    class ShaderFloatParam
    {
    public:

        ShaderFloatParam(const P3DChunk&);

        static std::unique_ptr<ShaderFloatParam> Load(const P3DChunk& chunk) { return std::make_unique<ShaderFloatParam>(chunk); }

        const std::string& GetKey() const { return _key; }
        const float& GetValue() const { return _value; }

    private:

        std::string _key;
        float _value;

    };

    class ShaderColorParam
    {
    public:

        ShaderColorParam(const P3DChunk&);

        static std::unique_ptr<ShaderColorParam> Load(const P3DChunk& chunk) { return std::make_unique<ShaderColorParam>(chunk); }

        const std::string& GetKey() const { return _key; }
        const uint8_t& GetR() const { return _r; }
        const uint8_t& GetG() const { return _g; }
        const uint8_t& GetB() const { return _b; }
        const uint8_t& GetA() const { return _a; }

    private:

        std::string _key;
        uint8_t _r;
        uint8_t _g;
        uint8_t _b;
        uint8_t _a;

    };

    class CompositeDrawable
    {
    public:

        CompositeDrawable(const P3DChunk&);

        static std::unique_ptr<CompositeDrawable> Load(const P3DChunk& chunk) { return std::make_unique<CompositeDrawable>(chunk); }

        const std::string& GetName() const { return _name; }
        const std::string& GetSkeletonName() const { return _skeletonName; }
        const std::unique_ptr<CompositeDrawablePropList>& GetPropList() const { return _propList; }

    private:

        std::string _name;
        std::string _skeletonName;
        std::unique_ptr<CompositeDrawablePropList> _propList;

    };

    class CompositeDrawablePropList
    {
    public:

        CompositeDrawablePropList(const P3DChunk&);

        static std::unique_ptr<CompositeDrawablePropList> Load(const P3DChunk& chunk) { return std::make_unique<CompositeDrawablePropList>(chunk); }

        const uint32_t& GetNumElements() const { return _numElements; }
        const std::vector<std::unique_ptr<CompositeDrawableProp>>& GetProps() const { return _props; }

    private:

        uint32_t _numElements;
        std::vector<std::unique_ptr<CompositeDrawableProp>> _props;

    };

    class CompositeDrawableProp
    {
    public:

        CompositeDrawableProp(const P3DChunk&);

        static std::unique_ptr<CompositeDrawableProp> Load(const P3DChunk& chunk) { return std::make_unique<CompositeDrawableProp>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetIsTrans() const { return _isTrans; }
        const uint32_t& GetSkeletonJoint() const { return _skeletonJoint; }
        const float& GetSortOrder() const { return _sortOrder; }

    private:

        std::string _name;
        uint32_t _isTrans;
        uint32_t _skeletonJoint;
        float _sortOrder;

    };

    class CompositeDrawableSortOrder
    {
    public:

        CompositeDrawableSortOrder(const P3DChunk&);

        static std::unique_ptr<CompositeDrawableSortOrder> Load(const P3DChunk& chunk) { return std::make_unique<CompositeDrawableSortOrder>(chunk); }

        const float& GetValue() const { return _value; }

    private:

        float _value;

    };

    class Intersect
    {
    public:

        Intersect(const P3DChunk&);

        static std::unique_ptr<Intersect> Load(const P3DChunk& chunk) { return std::make_unique<Intersect>(chunk); }

        const std::vector<uint32_t>& GetIndices() const { return _indices; }
        const std::vector<glm::vec3>& GetPositions() const { return _positions; }
        const std::vector<glm::vec3>& GetNormals() const { return _normals; }
        const std::unique_ptr<BoundingBox>& GetBounds() const { return _bounds; }

    private:

        std::vector<uint32_t> _indices;
        std::vector<glm::vec3> _positions;
        std::vector<glm::vec3> _normals;
        std::unique_ptr<BoundingBox> _bounds;

    };

    class WorldSphere
    {
    public:

        WorldSphere(const P3DChunk&);

        static std::unique_ptr<WorldSphere> Load(const P3DChunk& chunk) { return std::make_unique<WorldSphere>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetMeshCount() const { return _meshCount; }
        const uint32_t& GetBillboardCount() const { return _billboardCount; }
        const std::unique_ptr<Animation>& GetAnimation() const { return _animation; }
        const std::vector<std::unique_ptr<Skeleton>>& GetSkeletons() const { return _skeletons; }
        const std::vector<std::unique_ptr<BillboardQuadGroup>>& GetBillboards() const { return _billboards; }
        const std::vector<std::unique_ptr<Mesh>>& GetMeshes() const { return _meshes; }
        const std::unique_ptr<CompositeDrawable>& GetCompositeDrawable() const { return _compositeDrawable; }
        const std::unique_ptr<LensFlare>& GetLensFlare() const { return _lensFlare; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _meshCount;
        uint32_t _billboardCount;
        std::unique_ptr<Animation> _animation;
        std::vector<std::unique_ptr<Skeleton>> _skeletons;
        std::vector<std::unique_ptr<BillboardQuadGroup>> _billboards;
        std::vector<std::unique_ptr<Mesh>> _meshes;
        std::unique_ptr<CompositeDrawable> _compositeDrawable;
        std::unique_ptr<LensFlare> _lensFlare;

    };

    class LensFlare
    {
    public:

        LensFlare(const P3DChunk&);

        static std::unique_ptr<LensFlare> Load(const P3DChunk& chunk) { return std::make_unique<LensFlare>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetBillboardCount() const { return _billboardCount; }
        const std::vector<std::unique_ptr<BillboardQuadGroup>>& GetBillboards() const { return _billboards; }
        const std::unique_ptr<CompositeDrawable>& GetCompositeDrawable() const { return _compositeDrawable; }

    private:

        std::string _name;
        uint32_t _billboardCount;
        std::vector<std::unique_ptr<BillboardQuadGroup>> _billboards;
        std::unique_ptr<CompositeDrawable> _compositeDrawable;

    };

    class BillboardQuad
    {
    public:

        BillboardQuad(const P3DChunk&);

        static std::unique_ptr<BillboardQuad> Load(const P3DChunk& chunk) { return std::make_unique<BillboardQuad>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const std::string& GetMode() const { return _mode; }
        const glm::vec3& GetTranslation() const { return _translation; }
        const uint32_t& GetColor() const { return _color; }
        const glm::vec2& GetUv0() const { return _uv0; }
        const glm::vec2& GetUv1() const { return _uv1; }
        const glm::vec2& GetUv2() const { return _uv2; }
        const glm::vec2& GetUv3() const { return _uv3; }
        const float& GetWidth() const { return _width; }
        const float& GetHeight() const { return _height; }
        const float& GetDistance() const { return _distance; }
        const glm::vec2& GetUvOffset() const { return _uvOffset; }
        const std::unique_ptr<BillboardDisplayInfo>& GetDisplayInfo() const { return _displayInfo; }
        const std::unique_ptr<BillboardPerspectiveInfo>& GetPerspectiveInfo() const { return _perspectiveInfo; }

    private:

        uint32_t _version;
        std::string _name;
        std::string _mode;
        glm::vec3 _translation;
        uint32_t _color;
        glm::vec2 _uv0;
        glm::vec2 _uv1;
        glm::vec2 _uv2;
        glm::vec2 _uv3;
        float _width;
        float _height;
        float _distance;
        glm::vec2 _uvOffset;
        std::unique_ptr<BillboardDisplayInfo> _displayInfo;
        std::unique_ptr<BillboardPerspectiveInfo> _perspectiveInfo;

    };

    class BillboardQuadGroup
    {
    public:

        BillboardQuadGroup(const P3DChunk&);

        static std::unique_ptr<BillboardQuadGroup> Load(const P3DChunk& chunk) { return std::make_unique<BillboardQuadGroup>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const std::string& GetShader() const { return _shader; }
        const uint32_t& GetZTest() const { return _zTest; }
        const uint32_t& GetZWrite() const { return _zWrite; }
        const uint32_t& GetFog() const { return _fog; }
        const uint32_t& GetQuadCount() const { return _quadCount; }
        const std::vector<std::unique_ptr<BillboardQuad>>& GetQuads() const { return _quads; }

    private:

        uint32_t _version;
        std::string _name;
        std::string _shader;
        uint32_t _zTest;
        uint32_t _zWrite;
        uint32_t _fog;
        uint32_t _quadCount;
        std::vector<std::unique_ptr<BillboardQuad>> _quads;

    };

    class BillboardDisplayInfo
    {
    public:

        BillboardDisplayInfo(const P3DChunk&);

        static std::unique_ptr<BillboardDisplayInfo> Load(const P3DChunk& chunk) { return std::make_unique<BillboardDisplayInfo>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const glm::quat& GetRotation() const { return _rotation; }
        const std::string& GetCutOffMode() const { return _cutOffMode; }
        const glm::vec2& GetUvOffsetRange() const { return _uvOffsetRange; }
        const float& GetSourceRange() const { return _sourceRange; }
        const float& GetEdgeRange() const { return _edgeRange; }

    private:

        uint32_t _version;
        glm::quat _rotation;
        std::string _cutOffMode;
        glm::vec2 _uvOffsetRange;
        float _sourceRange;
        float _edgeRange;

    };

    class BillboardPerspectiveInfo
    {
    public:

        BillboardPerspectiveInfo(const P3DChunk&);

        static std::unique_ptr<BillboardPerspectiveInfo> Load(const P3DChunk& chunk) { return std::make_unique<BillboardPerspectiveInfo>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetValue() const { return _value; }

    private:

        uint32_t _version;
        uint32_t _value;

    };

    class Texture
    {
    public:

        Texture(const P3DChunk&);

        static std::unique_ptr<Texture> Load(const P3DChunk& chunk) { return std::make_unique<Texture>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetWidth() const { return _width; }
        const uint32_t& GetHeight() const { return _height; }
        const uint32_t& GetBpp() const { return _bpp; }
        const uint32_t& GetAlphaDepth() const { return _alphaDepth; }
        const uint32_t& GetNumMipMaps() const { return _numMipMaps; }
        const uint32_t& GetTextureType() const { return _textureType; }
        const uint32_t& GetUsage() const { return _usage; }
        const uint32_t& GetPriority() const { return _priority; }
        const std::unique_ptr<Image>& GetImage() const { return _image; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _width;
        uint32_t _height;
        uint32_t _bpp;
        uint32_t _alphaDepth;
        uint32_t _numMipMaps;
        uint32_t _textureType;
        uint32_t _usage;
        uint32_t _priority;
        std::unique_ptr<Image> _image;

    };

    class Image
    {
    public:

        Image(const P3DChunk&);

        static std::unique_ptr<Image> Load(const P3DChunk& chunk) { return std::make_unique<Image>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetWidth() const { return _width; }
        const uint32_t& GetHeight() const { return _height; }
        const uint32_t& GetBpp() const { return _bpp; }
        const uint32_t& GetPalettized() const { return _palettized; }
        const uint32_t& GetHasAlpha() const { return _hasAlpha; }
        const uint32_t& GetFormat() const { return _format; }
        const std::vector<uint8_t>& GetData() const { return _data; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _width;
        uint32_t _height;
        uint32_t _bpp;
        uint32_t _palettized;
        uint32_t _hasAlpha;
        uint32_t _format;
        std::vector<uint8_t> _data;

    };

    class ImageData
    {
    public:

        ImageData(const P3DChunk&);

        static std::unique_ptr<ImageData> Load(const P3DChunk& chunk) { return std::make_unique<ImageData>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<uint8_t>& GetData() const { return _data; }

    private:

        uint32_t _size;
        std::vector<uint8_t> _data;

    };

    class TextureFont
    {
    public:

        TextureFont(const P3DChunk&);

        static std::unique_ptr<TextureFont> Load(const P3DChunk& chunk) { return std::make_unique<TextureFont>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const std::string& GetShader() const { return _shader; }
        const float& GetSize() const { return _size; }
        const float& GetWidth() const { return _width; }
        const float& GetHeight() const { return _height; }
        const float& GetBaseLine() const { return _baseLine; }
        const uint32_t& GetNumTextures() const { return _numTextures; }
        const std::vector<std::unique_ptr<Texture>>& GetTextures() const { return _textures; }
        const std::vector<FontGlyph>& GetGlyphs() const { return _glyphs; }

    private:

        uint32_t _version;
        std::string _name;
        std::string _shader;
        float _size;
        float _width;
        float _height;
        float _baseLine;
        uint32_t _numTextures;
        std::vector<std::unique_ptr<Texture>> _textures;
        std::vector<FontGlyph> _glyphs;

    };

    class FontGlyphs
    {
    public:

        FontGlyphs(const P3DChunk&);

        static std::unique_ptr<FontGlyphs> Load(const P3DChunk& chunk) { return std::make_unique<FontGlyphs>(chunk); }

        const uint32_t& GetSize() const { return _size; }
        const std::vector<FontGlyph>& GetGlyphs() const { return _glyphs; }

    private:

        uint32_t _size;
        std::vector<FontGlyph> _glyphs;

    };

    class Sprite
    {
    public:

        Sprite(const P3DChunk&);

        static std::unique_ptr<Sprite> Load(const P3DChunk& chunk) { return std::make_unique<Sprite>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetNativeX() const { return _nativeX; }
        const uint32_t& GetNativeY() const { return _nativeY; }
        const std::string& GetShader() const { return _shader; }
        const uint32_t& GetWidth() const { return _width; }
        const uint32_t& GetHeight() const { return _height; }
        const uint32_t& GetImageCount() const { return _imageCount; }
        const uint32_t& GetBlitBorder() const { return _blitBorder; }
        const std::vector<std::unique_ptr<Image>>& GetImages() const { return _images; }

    private:

        std::string _name;
        uint32_t _nativeX;
        uint32_t _nativeY;
        std::string _shader;
        uint32_t _width;
        uint32_t _height;
        uint32_t _imageCount;
        uint32_t _blitBorder;
        std::vector<std::unique_ptr<Image>> _images;

    };

    class FrontendScreen
    {
    public:

        FrontendScreen(const P3DChunk&);

        static std::unique_ptr<FrontendScreen> Load(const P3DChunk& chunk) { return std::make_unique<FrontendScreen>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetNumPages() const { return _numPages; }
        const std::vector<std::string>& GetPageNames() const { return _pageNames; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _numPages;
        std::vector<std::string> _pageNames;

    };

    class FrontendProject
    {
    public:

        FrontendProject(const P3DChunk&);

        static std::unique_ptr<FrontendProject> Load(const P3DChunk& chunk) { return std::make_unique<FrontendProject>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetResX() const { return _resX; }
        const uint32_t& GetResY() const { return _resY; }
        const std::string& GetPlatform() const { return _platform; }
        const std::string& GetPagePath() const { return _pagePath; }
        const std::string& GetResourcePath() const { return _resourcePath; }
        const std::string& GetScreenPath() const { return _screenPath; }
        const std::vector<std::unique_ptr<FrontendPage>>& GetPages() const { return _pages; }
        const std::vector<std::unique_ptr<FrontendScreen>>& GetScreens() const { return _screens; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _resX;
        uint32_t _resY;
        std::string _platform;
        std::string _pagePath;
        std::string _resourcePath;
        std::string _screenPath;
        std::vector<std::unique_ptr<FrontendPage>> _pages;
        std::vector<std::unique_ptr<FrontendScreen>> _screens;

    };

    class FrontendPage
    {
    public:

        FrontendPage(const P3DChunk&);

        static std::unique_ptr<FrontendPage> Load(const P3DChunk& chunk) { return std::make_unique<FrontendPage>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetResX() const { return _resX; }
        const uint32_t& GetResY() const { return _resY; }
        const std::vector<std::unique_ptr<FrontendLayer>>& GetLayers() const { return _layers; }
        const std::vector<std::unique_ptr<FrontendImageResource>>& GetImageResources() const { return _imageResources; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _resX;
        uint32_t _resY;
        std::vector<std::unique_ptr<FrontendLayer>> _layers;
        std::vector<std::unique_ptr<FrontendImageResource>> _imageResources;

    };

    class FrontendLayer
    {
    public:

        FrontendLayer(const P3DChunk&);

        static std::unique_ptr<FrontendLayer> Load(const P3DChunk& chunk) { return std::make_unique<FrontendLayer>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetVisible() const { return _visible; }
        const uint32_t& GetEditable() const { return _editable; }
        const uint32_t& GetAlpha() const { return _alpha; }
        const std::vector<std::unique_ptr<FrontendGroup>>& GetGroups() const { return _groups; }
        const std::vector<std::unique_ptr<FrontendMultiSprite>>& GetMultiSprites() const { return _multiSprites; }
        const std::vector<std::unique_ptr<FrontendMultiText>>& GetMultiTexts() const { return _multiTexts; }
        const std::vector<std::unique_ptr<FrontendObject>>& GetObjects() const { return _objects; }
        const std::vector<std::unique_ptr<FrontendPolygon>>& GetPolygons() const { return _polygons; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _visible;
        uint32_t _editable;
        uint32_t _alpha;
        std::vector<std::unique_ptr<FrontendGroup>> _groups;
        std::vector<std::unique_ptr<FrontendMultiSprite>> _multiSprites;
        std::vector<std::unique_ptr<FrontendMultiText>> _multiTexts;
        std::vector<std::unique_ptr<FrontendObject>> _objects;
        std::vector<std::unique_ptr<FrontendPolygon>> _polygons;

    };

    class FrontendGroup
    {
    public:

        FrontendGroup(const P3DChunk&);

        static std::unique_ptr<FrontendGroup> Load(const P3DChunk& chunk) { return std::make_unique<FrontendGroup>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetAlpha() const { return _alpha; }
        const std::vector<std::unique_ptr<FrontendGroup>>& GetChildren() const { return _children; }
        const std::vector<std::unique_ptr<FrontendMultiSprite>>& GetMultiSprites() const { return _multiSprites; }
        const std::vector<std::unique_ptr<FrontendMultiText>>& GetMultiTexts() const { return _multiTexts; }
        const std::vector<std::unique_ptr<FrontendPolygon>>& GetPolygons() const { return _polygons; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _alpha;
        std::vector<std::unique_ptr<FrontendGroup>> _children;
        std::vector<std::unique_ptr<FrontendMultiSprite>> _multiSprites;
        std::vector<std::unique_ptr<FrontendMultiText>> _multiTexts;
        std::vector<std::unique_ptr<FrontendPolygon>> _polygons;

    };

    class FrontendMultiSprite
    {
    public:

        FrontendMultiSprite(const P3DChunk&);

        static std::unique_ptr<FrontendMultiSprite> Load(const P3DChunk& chunk) { return std::make_unique<FrontendMultiSprite>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const int32_t& GetPositionX() const { return _positionX; }
        const int32_t& GetPositionY() const { return _positionY; }
        const uint32_t& GetDimensionX() const { return _dimensionX; }
        const uint32_t& GetDimensionY() const { return _dimensionY; }
        const uint32_t& GetAlignX() const { return _alignX; }
        const uint32_t& GetAlignY() const { return _alignY; }
        const uint32_t& GetColor() const { return _color; }
        const uint32_t& GetTranslucent() const { return _translucent; }
        const float& GetRotation() const { return _rotation; }
        const uint32_t& GetNumImages() const { return _numImages; }
        const std::vector<std::string>& GetImageNames() const { return _imageNames; }

    private:

        std::string _name;
        uint32_t _version;
        int32_t _positionX;
        int32_t _positionY;
        uint32_t _dimensionX;
        uint32_t _dimensionY;
        uint32_t _alignX;
        uint32_t _alignY;
        uint32_t _color;
        uint32_t _translucent;
        float _rotation;
        uint32_t _numImages;
        std::vector<std::string> _imageNames;

    };

    class FrontendMultiText
    {
    public:

        FrontendMultiText(const P3DChunk&);

        static std::unique_ptr<FrontendMultiText> Load(const P3DChunk& chunk) { return std::make_unique<FrontendMultiText>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const int32_t& GetPositionX() const { return _positionX; }
        const int32_t& GetPositionY() const { return _positionY; }
        const uint32_t& GetDimensionX() const { return _dimensionX; }
        const uint32_t& GetDimensionY() const { return _dimensionY; }
        const uint32_t& GetAlignX() const { return _alignX; }
        const uint32_t& GetAlignY() const { return _alignY; }
        const uint32_t& GetColor() const { return _color; }
        const uint32_t& GetTranslucent() const { return _translucent; }
        const float& GetRotation() const { return _rotation; }
        const std::string& GetFontName() const { return _fontName; }
        const uint8_t& GetShadowEnabled() const { return _shadowEnabled; }
        const uint32_t& GetShadowColor() const { return _shadowColor; }
        const int32_t& GetShadowOffsetX() const { return _shadowOffsetX; }
        const int32_t& GetShadowOffsetY() const { return _shadowOffsetY; }
        const uint32_t& GetCurrent() const { return _current; }
        const std::vector<std::unique_ptr<FrontendStringTextBible>>& GetTextBibles() const { return _textBibles; }

    private:

        std::string _name;
        uint32_t _version;
        int32_t _positionX;
        int32_t _positionY;
        uint32_t _dimensionX;
        uint32_t _dimensionY;
        uint32_t _alignX;
        uint32_t _alignY;
        uint32_t _color;
        uint32_t _translucent;
        float _rotation;
        std::string _fontName;
        uint8_t _shadowEnabled;
        uint32_t _shadowColor;
        int32_t _shadowOffsetX;
        int32_t _shadowOffsetY;
        uint32_t _current;
        std::vector<std::unique_ptr<FrontendStringTextBible>> _textBibles;

    };

    class FrontendStringTextBible
    {
    public:

        FrontendStringTextBible(const P3DChunk&);

        static std::unique_ptr<FrontendStringTextBible> Load(const P3DChunk& chunk) { return std::make_unique<FrontendStringTextBible>(chunk); }

        const std::string& GetName() const { return _name; }
        const std::string& GetKey() const { return _key; }

    private:

        std::string _name;
        std::string _key;

    };

    class FrontendObject
    {
    public:

        FrontendObject(const P3DChunk&);

        static std::unique_ptr<FrontendObject> Load(const P3DChunk& chunk) { return std::make_unique<FrontendObject>(chunk); }

        const std::string& GetName() const { return _name; }

    private:

        std::string _name;

    };

    class FrontendPolygon
    {
    public:

        FrontendPolygon(const P3DChunk&);

        static std::unique_ptr<FrontendPolygon> Load(const P3DChunk& chunk) { return std::make_unique<FrontendPolygon>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const uint32_t& GetTranslucent() const { return _translucent; }
        const uint32_t& GetNumPoints() const { return _numPoints; }
        const std::vector<glm::vec3>& GetPoints() const { return _points; }
        const std::vector<uint32_t>& GetColors() const { return _colors; }

    private:

        std::string _name;
        uint32_t _version;
        uint32_t _translucent;
        uint32_t _numPoints;
        std::vector<glm::vec3> _points;
        std::vector<uint32_t> _colors;

    };

    class FrontendImageResource
    {
    public:

        FrontendImageResource(const P3DChunk&);

        static std::unique_ptr<FrontendImageResource> Load(const P3DChunk& chunk) { return std::make_unique<FrontendImageResource>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetFilepath() const { return _filepath; }

    private:

        std::string _name;
        uint32_t _version;
        std::string _filepath;

    };

    class Locator2
    {
    public:

        Locator2(const P3DChunk&);

        static std::unique_ptr<Locator2> Load(const P3DChunk& chunk) { return std::make_unique<Locator2>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetType() const { return _type; }
        const uint32_t& GetDataSize() const { return _dataSize; }
        const std::vector<std::unique_ptr<TriggerVolume>>& GetTriggers() const { return _triggers; }

    private:

        std::string _name;
        uint32_t _type;
        uint32_t _dataSize;
        std::vector<std::unique_ptr<TriggerVolume>> _triggers;

    };

    class TriggerVolume
    {
    public:

        TriggerVolume(const P3DChunk&);

        static std::unique_ptr<TriggerVolume> Load(const P3DChunk& chunk) { return std::make_unique<TriggerVolume>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetIsRect() const { return _isRect; }
        const glm::vec3& GetBounds() const { return _bounds; }
        const glm::mat4& GetTransform() const { return _transform; }

    private:

        std::string _name;
        uint32_t _isRect;
        glm::vec3 _bounds;
        glm::mat4 _transform;

    };

    class Camera
    {
    public:

        Camera(const P3DChunk&);

        static std::unique_ptr<Camera> Load(const P3DChunk& chunk) { return std::make_unique<Camera>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const float& GetFov() const { return _fov; }
        const float& GetAspectRatio() const { return _aspectRatio; }
        const float& GetNearClip() const { return _nearClip; }
        const float& GetFarClip() const { return _farClip; }
        const glm::vec3& GetPosition() const { return _position; }
        const glm::vec3& GetForward() const { return _forward; }
        const glm::vec3& GetUp() const { return _up; }

    private:

        std::string _name;
        uint32_t _version;
        float _fov;
        float _aspectRatio;
        float _nearClip;
        float _farClip;
        glm::vec3 _position;
        glm::vec3 _forward;
        glm::vec3 _up;

    };

    class MultiController
    {
    public:

        MultiController(const P3DChunk&);

        static std::unique_ptr<MultiController> Load(const P3DChunk& chunk) { return std::make_unique<MultiController>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const float& GetLength() const { return _length; }
        const float& GetFrameRate() const { return _frameRate; }
        const uint32_t& GetNumTracks() const { return _numTracks; }
        const std::unique_ptr<MultiControllerTracks>& GetTracks() const { return _tracks; }

    private:

        std::string _name;
        uint32_t _version;
        float _length;
        float _frameRate;
        uint32_t _numTracks;
        std::unique_ptr<MultiControllerTracks> _tracks;

    };

    class MultiControllerTracks
    {
    public:

        MultiControllerTracks(const P3DChunk&);

        static std::unique_ptr<MultiControllerTracks> Load(const P3DChunk& chunk) { return std::make_unique<MultiControllerTracks>(chunk); }

        const uint32_t& GetNumTracks() const { return _numTracks; }
        const std::vector<std::string>& GetTrackNames() const { return _trackNames; }
        const std::vector<float>& GetTrackStartTimes() const { return _trackStartTimes; }
        const std::vector<float>& GetTrackEndTimes() const { return _trackEndTimes; }
        const std::vector<float>& GetTrackScales() const { return _trackScales; }

    private:

        uint32_t _numTracks;
        std::vector<std::string> _trackNames;
        std::vector<float> _trackStartTimes;
        std::vector<float> _trackEndTimes;
        std::vector<float> _trackScales;

    };

    class CollisionObject
    {
    public:

        CollisionObject(const P3DChunk&);

        static std::unique_ptr<CollisionObject> Load(const P3DChunk& chunk) { return std::make_unique<CollisionObject>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetMaterialName() const { return _materialName; }
        const uint32_t& GetNumSubObjects() const { return _numSubObjects; }
        const uint32_t& GetNumVolumeOwners() const { return _numVolumeOwners; }
        const std::vector<std::unique_ptr<CollisionVolumeOwner>>& GetVolumeOwners() const { return _volumeOwners; }
        const std::unique_ptr<CollisionVolume>& GetVolume() const { return _volume; }
        const std::unique_ptr<CollisionObjectAttribute>& GetAttribute() const { return _attribute; }

    private:

        std::string _name;
        uint32_t _version;
        std::string _materialName;
        uint32_t _numSubObjects;
        uint32_t _numVolumeOwners;
        std::vector<std::unique_ptr<CollisionVolumeOwner>> _volumeOwners;
        std::unique_ptr<CollisionVolume> _volume;
        std::unique_ptr<CollisionObjectAttribute> _attribute;

    };

    class CollisionVolume
    {
    public:

        CollisionVolume(const P3DChunk&);

        static std::unique_ptr<CollisionVolume> Load(const P3DChunk& chunk) { return std::make_unique<CollisionVolume>(chunk); }

        const uint32_t& GetObjectRefIndex() const { return _objectRefIndex; }
        const int32_t& GetOwnerIndex() const { return _ownerIndex; }
        const uint32_t& GetNumSubVolumes() const { return _numSubVolumes; }
        const std::vector<std::unique_ptr<CollisionVolume>>& GetSubVolumes() const { return _subVolumes; }
        const std::unique_ptr<CollisionBBoxVolume>& GetBBox() const { return _bBox; }
        const std::unique_ptr<CollisionOBBoxVolume>& GetObBox() const { return _obBox; }
        const std::unique_ptr<CollisionSphere>& GetSphere() const { return _sphere; }
        const std::unique_ptr<CollisionCylinder>& GetCylinder() const { return _cylinder; }

    private:

        uint32_t _objectRefIndex;
        int32_t _ownerIndex;
        uint32_t _numSubVolumes;
        std::vector<std::unique_ptr<CollisionVolume>> _subVolumes;
        std::unique_ptr<CollisionBBoxVolume> _bBox;
        std::unique_ptr<CollisionOBBoxVolume> _obBox;
        std::unique_ptr<CollisionSphere> _sphere;
        std::unique_ptr<CollisionCylinder> _cylinder;

    };

    class CollisionSphere
    {
    public:

        CollisionSphere(const P3DChunk&);

        static std::unique_ptr<CollisionSphere> Load(const P3DChunk& chunk) { return std::make_unique<CollisionSphere>(chunk); }

        const float& GetRadius() const { return _radius; }
        const std::vector<glm::vec3>& GetVectors() const { return _vectors; }

    private:

        float _radius;
        std::vector<glm::vec3> _vectors;

    };

    class CollisionCylinder
    {
    public:

        CollisionCylinder(const P3DChunk&);

        static std::unique_ptr<CollisionCylinder> Load(const P3DChunk& chunk) { return std::make_unique<CollisionCylinder>(chunk); }

        const float& GetRadius() const { return _radius; }
        const float& GetLength() const { return _length; }
        const uint16_t& GetFlatEnd() const { return _flatEnd; }
        const std::vector<glm::vec3>& GetVectors() const { return _vectors; }

    private:

        float _radius;
        float _length;
        uint16_t _flatEnd;
        std::vector<glm::vec3> _vectors;

    };

    class CollisionOBBoxVolume
    {
    public:

        CollisionOBBoxVolume(const P3DChunk&);

        static std::unique_ptr<CollisionOBBoxVolume> Load(const P3DChunk& chunk) { return std::make_unique<CollisionOBBoxVolume>(chunk); }

        const glm::vec3& GetHalfExtents() const { return _halfExtents; }
        const std::vector<glm::vec3>& GetVectors() const { return _vectors; }

    private:

        glm::vec3 _halfExtents;
        std::vector<glm::vec3> _vectors;

    };

    class CollisionBBoxVolume
    {
    public:

        CollisionBBoxVolume(const P3DChunk&);

        static std::unique_ptr<CollisionBBoxVolume> Load(const P3DChunk& chunk) { return std::make_unique<CollisionBBoxVolume>(chunk); }

        const uint32_t& GetNothing() const { return _nothing; }

    private:

        uint32_t _nothing;

    };

    class CollisionVector
    {
    public:

        CollisionVector(const P3DChunk&);

        static std::unique_ptr<CollisionVector> Load(const P3DChunk& chunk) { return std::make_unique<CollisionVector>(chunk); }

        const glm::vec3& GetValue() const { return _value; }

    private:

        glm::vec3 _value;

    };

    class CollisionVolumeOwner
    {
    public:

        CollisionVolumeOwner(const P3DChunk&);

        static std::unique_ptr<CollisionVolumeOwner> Load(const P3DChunk& chunk) { return std::make_unique<CollisionVolumeOwner>(chunk); }

        const uint32_t& GetNumNames() const { return _numNames; }
        const std::vector<std::unique_ptr<CollisionVolumeOwnerName>>& GetNames() const { return _names; }

    private:

        uint32_t _numNames;
        std::vector<std::unique_ptr<CollisionVolumeOwnerName>> _names;

    };

    class CollisionVolumeOwnerName
    {
    public:

        CollisionVolumeOwnerName(const P3DChunk&);

        static std::unique_ptr<CollisionVolumeOwnerName> Load(const P3DChunk& chunk) { return std::make_unique<CollisionVolumeOwnerName>(chunk); }

        const std::string& GetName() const { return _name; }

    private:

        std::string _name;

    };

    class CollisionObjectAttribute
    {
    public:

        CollisionObjectAttribute(const P3DChunk&);

        static std::unique_ptr<CollisionObjectAttribute> Load(const P3DChunk& chunk) { return std::make_unique<CollisionObjectAttribute>(chunk); }

        const uint16_t& GetStatic() const { return _static; }
        const uint32_t& GetDefaultArea() const { return _defaultArea; }
        const uint16_t& GetCanRoll() const { return _canRoll; }
        const uint16_t& GetCanSlide() const { return _canSlide; }
        const uint16_t& GetCanSpin() const { return _canSpin; }
        const uint16_t& GetCanBounce() const { return _canBounce; }
        const uint32_t& GetTodo1() const { return _todo1; }
        const uint32_t& GetTodo2() const { return _todo2; }
        const uint32_t& GetTodo3() const { return _todo3; }

    private:

        uint16_t _static;
        uint32_t _defaultArea;
        uint16_t _canRoll;
        uint16_t _canSlide;
        uint16_t _canSpin;
        uint16_t _canBounce;
        uint32_t _todo1;
        uint32_t _todo2;
        uint32_t _todo3;

    };

    class FenceWrapper
    {
    public:

        FenceWrapper(const P3DChunk&);

        static std::unique_ptr<FenceWrapper> Load(const P3DChunk& chunk) { return std::make_unique<FenceWrapper>(chunk); }

        const std::unique_ptr<Fence>& GetFence() const { return _fence; }

    private:

        std::unique_ptr<Fence> _fence;

    };

    class Fence
    {
    public:

        Fence(const P3DChunk&);

        static std::unique_ptr<Fence> Load(const P3DChunk& chunk) { return std::make_unique<Fence>(chunk); }

        const glm::vec3& GetStart() const { return _start; }
        const glm::vec3& GetEnd() const { return _end; }
        const glm::vec3& GetNormal() const { return _normal; }

    private:

        glm::vec3 _start;
        glm::vec3 _end;
        glm::vec3 _normal;

    };

    class Set
    {
    public:

        Set(const P3DChunk&);

        static std::unique_ptr<Set> Load(const P3DChunk& chunk) { return std::make_unique<Set>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetNumTextures() const { return _numTextures; }
        const std::vector<std::unique_ptr<Texture>>& GetTextures() const { return _textures; }

    private:

        std::string _name;
        uint32_t _numTextures;
        std::vector<std::unique_ptr<Texture>> _textures;

    };

    class Path
    {
    public:

        Path(const P3DChunk&);

        static std::unique_ptr<Path> Load(const P3DChunk& chunk) { return std::make_unique<Path>(chunk); }

        const uint32_t& GetNumPoints() const { return _numPoints; }
        const std::vector<glm::vec3>& GetPoints() const { return _points; }

    private:

        uint32_t _numPoints;
        std::vector<glm::vec3> _points;

    };

    class Intersection
    {
    public:

        Intersection(const P3DChunk&);

        static std::unique_ptr<Intersection> Load(const P3DChunk& chunk) { return std::make_unique<Intersection>(chunk); }

        const std::string& GetName() const { return _name; }
        const glm::vec3& GetPosition() const { return _position; }
        const float& GetRadius() const { return _radius; }
        const uint32_t& GetTrafficBehaviour() const { return _trafficBehaviour; }

    private:

        std::string _name;
        glm::vec3 _position;
        float _radius;
        uint32_t _trafficBehaviour;

    };

    class RoadDataSegment
    {
    public:

        RoadDataSegment(const P3DChunk&);

        static std::unique_ptr<RoadDataSegment> Load(const P3DChunk& chunk) { return std::make_unique<RoadDataSegment>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo0() const { return _todo0; }
        const uint32_t& GetLanes() const { return _lanes; }
        const uint32_t& GetTodo1() const { return _todo1; }
        const glm::vec3& GetPosition0() const { return _position0; }
        const glm::vec3& GetPosition1() const { return _position1; }
        const glm::vec3& GetPosition2() const { return _position2; }

    private:

        std::string _name;
        uint32_t _todo0;
        uint32_t _lanes;
        uint32_t _todo1;
        glm::vec3 _position0;
        glm::vec3 _position1;
        glm::vec3 _position2;

    };

    class Road
    {
    public:

        Road(const P3DChunk&);

        static std::unique_ptr<Road> Load(const P3DChunk& chunk) { return std::make_unique<Road>(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetTodo0() const { return _todo0; }
        const std::string& GetStartIntersection() const { return _startIntersection; }
        const std::string& GetEndIntersection() const { return _endIntersection; }
        const uint32_t& GetMaxCars() const { return _maxCars; }
        const uint8_t& GetTodo1() const { return _todo1; }
        const uint8_t& GetTodo2() const { return _todo2; }
        const uint8_t& GetNoReset() const { return _noReset; }
        const uint8_t& GetTodo3() const { return _todo3; }

    private:

        std::string _name;
        uint32_t _todo0;
        std::string _startIntersection;
        std::string _endIntersection;
        uint32_t _maxCars;
        uint8_t _todo1;
        uint8_t _todo2;
        uint8_t _noReset;
        uint8_t _todo3;

    };

    class GameAttr
    {
    public:

        GameAttr(const P3DChunk&);

        static std::unique_ptr<GameAttr> Load(const P3DChunk& chunk) { return std::make_unique<GameAttr>(chunk); }

        const uint32_t& GetVersion() const { return _version; }
        const std::string& GetName() const { return _name; }
        const uint32_t& GetNumParams() const { return _numParams; }
        const std::vector<std::unique_ptr<GameAttrIntParam>>& GetParams() const { return _params; }

    private:

        uint32_t _version;
        std::string _name;
        uint32_t _numParams;
        std::vector<std::unique_ptr<GameAttrIntParam>> _params;

    };

    class GameAttrIntParam 
    {
    public:

        GameAttrIntParam (const P3DChunk&);

        static std::unique_ptr<GameAttrIntParam > Load(const P3DChunk& chunk) { return std::make_unique<GameAttrIntParam >(chunk); }

        const std::string& GetName() const { return _name; }
        const uint32_t& GetValue() const { return _value; }

    private:

        std::string _name;
        uint32_t _value;

    };

    class History
    {
    public:

        History(const P3DChunk&);

        static std::unique_ptr<History> Load(const P3DChunk& chunk) { return std::make_unique<History>(chunk); }

        const uint32_t& GetNumLines() const { return _numLines; }
        const std::vector<std::string>& GetLines() const { return _lines; }

    private:

        uint32_t _numLines;
        std::vector<std::string> _lines;

    };
}
